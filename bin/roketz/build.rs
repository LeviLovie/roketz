use anyhow::{Context, Result};
use std::{io::Write, path::PathBuf, sync::LazyLock};

const ROOT: &str = "../..";

macro_rules! relative_path {
    ($name: ident, $path: expr) => {
        static $name: LazyLock<String> = LazyLock::new(|| format!("{}/{}", ROOT, $path));
    };
}

macro_rules! path {
    ($name: expr) => {
        &(*$name)
    };
}

relative_path!(ASSETS_DIR, "assets");
static ASSETS_FILE: &str = "assets.rdss";

relative_path!(BANKS_DIR, "fmod/Build/Desktop");
relative_path!(BANKS_DEST, "assets/sound");

relative_path!(BANKS_BINDINGS, "crates/sound/src/codegen/bindings.rs");

fn main() {
    if let Err(e) = try_main() {
        eprintln!("Error: {:?}", e);
        std::process::exit(1);
    }
}

fn try_main() -> Result<()> {
    compile_assets().context("Failed to compile assets")?;
    copy_banks().context("Failed to copy banks")?;
    generate_fmod_bindings().context("Failed to generate FMOD bindings")?;

    Ok(())
}

fn watch_dir(dir: impl Into<std::path::PathBuf>) {
    let entries = std::fs::read_dir(dir.into())
        .expect("Failed to read directory")
        .filter_map(Result::ok)
        .map(|entry| entry.path())
        .collect::<Vec<_>>();
    for entry in entries {
        if entry.is_dir() {
            watch_dir(entry);
        } else {
            println!("cargo:rerun-if-changed={}", entry.display());
        }
    }
}

fn get_out_dir() -> Result<PathBuf> {
    let mut out = std::path::PathBuf::from(
        std::env::var("OUT_DIR").context("OUT_DIR environment variable not set")?,
    );
    for _ in 1..4 {
        out.pop();
    }
    Ok(out)
}

fn compile_assets() -> Result<()> {
    let out = get_out_dir().context("Failed to get output directory")?;
    let compiler = rdss::Compiler::builder()
        .from_sources(path!(ASSETS_DIR))
        .save_to(out.join(path!(ASSETS_FILE)))
        .build()
        .context("Failed to build compiler")?;
    compiler.compile().context("Compilation failed")?;
    watch_dir(path!(ASSETS_DIR));
    Ok(())
}

fn copy_banks() -> Result<()> {
    for entry in std::fs::read_dir(path!(BANKS_DIR))
        .context(format!("Failed to read directory {}", path!(BANKS_DIR)))?
        .filter_map(Result::ok)
    {
        let src = entry.path();
        if src.is_file() {
            let dest = std::path::PathBuf::from(path!(BANKS_DEST)).join(src.file_name().unwrap());
            std::fs::copy(&src, &dest).context(format!(
                "Failed to copy bank file from {} to {}",
                src.display(),
                dest.display()
            ))?;
        }
    }
    watch_dir(path!(BANKS_DIR));
    Ok(())
}

fn generate_fmod_bindings() -> Result<()> {
    let path = std::path::PathBuf::from(path!(BANKS_BINDINGS));
    let dir = path
        .parent()
        .context("Failed to get parent directory for bindings file")?;
    std::fs::create_dir_all(dir).context(format!(
        "Failed to create directory for bindings file at {}",
        dir.display()
    ))?;
    let mut file = std::fs::File::create(path!(BANKS_BINDINGS)).context(format!(
        "Failed to create bindings file at {}",
        path!(BANKS_BINDINGS)
    ))?;

    file.write_all(b"// This file is generated by the build script. Do not edit manually.\n\n")
        .context("Failed to write header to bindings file")?;
    #[cfg(not(feature = "fmod"))]
    file.write_all(b"// FMOD feature is disabled. Enable it ro generate bindings\n")
        .context("Failed to write feature comment to bindings file")?;

    #[cfg(feature = "fmod")]
    {
        use fmod::Utf8CStr;

        let builder = unsafe { fmod::studio::SystemBuilder::new() }
            .context("Failed to create FMOD system builder")?;
        let system = builder
            .build(
                128,
                fmod::studio::InitFlags::NORMAL,
                fmod::InitFlags::NORMAL,
            )
            .context("Failed to build FMOD system")?;

        let bank_dir = PathBuf::from(path!(BANKS_DEST));

        for entry in std::fs::read_dir(&bank_dir)? {
            let path = entry?.path();
            if path.extension().and_then(|e| e.to_str()) == Some("bank")
                && path
                    .file_name()
                    .unwrap_or_default()
                    .to_string_lossy()
                    .contains(".strings")
            {
                let cstring = std::ffi::CString::new(path.to_string_lossy().to_string())?;
                let bank_path: &Utf8CStr = Utf8CStr::from_cstr(&cstring)?;
                println!("Loading strings bank: {}", path.display());
                let bank = system.load_bank_file(bank_path, fmod::studio::LoadBankFlags::NORMAL)?;

                for event in bank.get_event_list()? {
                    let event_path = event.get_path()?;
                    writeln!(file, "// pub const : &str = \"{}\";", event_path)?;
                }
            }
        }

        for entry in std::fs::read_dir(&bank_dir)? {
            let path = entry?.path();
            if path.extension().and_then(|e| e.to_str()) == Some("bank")
                && !path
                    .file_name()
                    .unwrap_or_default()
                    .to_string_lossy()
                    .contains(".strings")
            {
                let cstring = std::ffi::CString::new(path.to_string_lossy().to_string())?;
                let bank_path: &Utf8CStr = Utf8CStr::from_cstr(&cstring)?;
                println!("Loading normal bank: {}", path.display());
                let bank = system.load_bank_file(bank_path, fmod::studio::LoadBankFlags::NORMAL)?;

                for event in bank.get_event_list()? {
                    let event_path = event.get_path()?;
                    writeln!(file, "// pub const : &str = \"{}\";", event_path)?;
                }
            }
        }
    }

    Ok(())
}
